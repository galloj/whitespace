package cz.galloj

class Program(val instructions: List<Instruction>) {
	/**
	 * Transforms the [Program] into Whitespace code
	 */
	fun getCode(): String {
		val sb = StringBuilder()
		for(instruction in instructions) {
			sb.append(instruction.getCode())
		}
		return sb.toString()
	}
	
	/**
	 * Transforms the [Program] into human-readable representation
	 */
	fun getRepresentation(): String {
		val sb = StringBuilder()
		for(instruction in instructions) {
			sb.append(instruction.getRepresentation())
			sb.append('\n')
		}
		return sb.toString()
	}
	
	override fun equals(other: Any?): Boolean {
		if(other !is Program) {
			return false
		}
		return instructions.equals(other.instructions)
	}
	
	override fun hashCode(): Int {
		return instructions.hashCode()
	}
	
	override fun toString(): String {
		return "Program(${instructions.toString()})"
	}
	
	companion object {
		/**
		 * Transforms Whitespace code into new [Program]
		 */
		fun fromCode(code: String): Program {
			val codeWithoutComments = code.replace(Regex("[^ \t\n]"), "")
			var index = 0
			val instructions = mutableListOf<Instruction>()
			while(index < codeWithoutComments.length) {
				val (parsedLength, newInstruction) = Instruction.fromCode(codeWithoutComments.substring(index))
				index += parsedLength
				instructions.add(newInstruction)
			}
			return Program(instructions)
		}
		
		/**
		 * Transforms human-readable representation generated by [getRepresentation] into new [Program]
		 */
		fun fromRepresentation(representation: String): Program {
			val lines = representation.split("\n").toMutableList()
			if(lines.isNotEmpty() && lines.last().isEmpty()) {
				lines.removeLast()
			}
			val instructions = mutableListOf<Instruction>()
			for(line in lines) {
				instructions.add(Instruction.fromRepresentation(line))
			}
			return Program(instructions)
		}
	}
}